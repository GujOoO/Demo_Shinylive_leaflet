[{"name":"app.R","content":"library(shiny)\r\nlibrary(leaflet)\r\nlibrary(RColorBrewer)\r\n\r\nui <- bootstrapPage(\r\n   tags$style(type = \"text/css\", \"html, body {width:100%;height:100%}\"),\r\n   leafletOutput(\"map\", width = \"100%\", height = \"100%\"),\r\n   absolutePanel(top = 10, right = 10,\r\n      sliderInput(\"range\", \"Magnitudes\", min(quakes$mag), max(quakes$mag),\r\n         value = range(quakes$mag), step = 0.1\r\n      ),\r\n      selectInput(\"colors\", \"Color Scheme\",\r\n         rownames(subset(brewer.pal.info, category %in% c(\"seq\", \"div\")))\r\n      ),\r\n      checkboxInput(\"legend\", \"Show legend\", TRUE)\r\n   )\r\n)\r\n\r\nserver <- function(input, output, session) {\r\n   \r\n   # Reactive expression for the data subsetted to what the user selected\r\n   filteredData <- reactive({\r\n      quakes[quakes$mag >= input$range[1] & quakes$mag <= input$range[2],]\r\n   })\r\n   \r\n   # This reactive expression represents the palette function,\r\n   # which changes as the user makes selections in UI.\r\n   colorpal <- reactive({\r\n      colorNumeric(input$colors, quakes$mag)\r\n   })\r\n   \r\n   output$map <- renderLeaflet({\r\n      # Use leaflet() here, and only include aspects of the map that\r\n      # won't need to change dynamically (at least, not unless the\r\n      # entire map is being torn down and recreated).\r\n      leaflet(quakes) %>% addTiles() %>%\r\n         fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))\r\n   })\r\n   \r\n   # Incremental changes to the map (in this case, replacing the\r\n   # circles when a new color is chosen) should be performed in\r\n   # an observer. Each independent set of things that can change\r\n   # should be managed in its own observer.\r\n   observe({\r\n      pal <- colorpal()\r\n      \r\n      leafletProxy(\"map\", data = filteredData()) %>%\r\n         clearShapes() %>%\r\n         addCircles(radius = ~10^mag/10, weight = 1, color = \"#777777\",\r\n            fillColor = ~pal(mag), fillOpacity = 0.7, popup = ~paste(mag)\r\n         )\r\n   })\r\n   \r\n   # Use a separate observer to recreate the legend as needed.\r\n   observe({\r\n      proxy <- leafletProxy(\"map\", data = quakes)\r\n      \r\n      # Remove any existing legend, and only if the legend is\r\n      # enabled, create a new one.\r\n      proxy %>% clearControls()\r\n      if (input$legend) {\r\n         pal <- colorpal()\r\n         proxy %>% addLegend(position = \"bottomright\",\r\n            pal = pal, values = ~mag\r\n         )\r\n      }\r\n   })\r\n}\r\n\r\nshinyApp(ui, server)","type":"text"}]
